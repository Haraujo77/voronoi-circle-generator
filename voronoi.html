<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Circle Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        #controls {
            max-width: 1200px;
            margin: 0 auto;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .control-group label {
            min-width: 200px;
            font-size: 14px;
        }
        .control-group input[type="range"] {
            flex: 1;
            max-width: 400px;
        }
        .control-group input[type="number"] {
            width: 80px;
            padding: 5px;
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .control-group select {
            padding: 5px;
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .control-group input[type="color"] {
            width: 60px;
            height: 35px;
            padding: 2px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            padding: 12px 24px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover {
            background: #3a8eef;
        }
        button:active {
            background: #2a7edf;
        }
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .mode-toggle button {
            padding: 8px 16px;
            font-size: 14px;
        }
        .mode-toggle button.active {
            background: #6ab04c;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls"></div>
    <script>
// Voronoi Circle Generator
// Generates Voronoi diagrams inside a circle with SVG export

let canvas;
let seedPoints = [];
let voronoiCells = [];
let delaunay;

// Parameters
let params = {
  canvasSize: 1024,
  cellCount: 6,
  targetAreaPct: 2.0, // percentage of circle area per cell
  circleDiameterRatio: 0.59,
  voronoiStrokeWeight: 2,
  circleStrokeWeight: 2,
  cornerStyle: 'MITER', // 'MITER' or 'ROUND'
  mode: 'direct', // 'direct' (set N) or 'area' (set area percentage)
  strokeColor: '#000000', // stroke color (hex)
  fillColor: '#ff0000', // fill color (hex), use 'none' for no fill
  cornerRadius: 50 // corner radius for rounded corners (0 = sharp)
};

let circleCenterX, circleCenterY, circleRadius;

// UI elements
let cellCountSlider, cellCountInput;
let areaPctSlider, areaPctInput;
let diameterSlider, diameterInput;
let voronoiThicknessSlider, voronoiThicknessInput;
let circleThicknessSlider, circleThicknessInput;
let cornerStyleSelect;
let modeToggleDirect, modeToggleArea;
let downloadButton;
let strokeColorInput, fillColorInput;
let cornerRadiusSlider, cornerRadiusInput;

function setup() {
  canvas = createCanvas(params.canvasSize, params.canvasSize);
  canvas.parent('canvas-container');
  pixelDensity(1);
  
  circleCenterX = width / 2;
  circleCenterY = height / 2;
  circleRadius = (width * params.circleDiameterRatio) / 2;
  
  setupUI();
  generateVoronoi();
}

function setupUI() {
  const controlsDiv = select('#controls');
  controlsDiv.html(''); // Clear existing
  
  // Mode toggle
  const modeGroup = createDiv();
  modeGroup.class('control-group');
  modeGroup.html('<label>Control Mode:</label>');
  const modeToggleDiv = createDiv();
  modeToggleDiv.class('mode-toggle');
  modeToggleDirect = createButton('Direct (Set N)');
  modeToggleArea = createButton('Area-Based (Set %)');
  modeToggleDirect.mousePressed(() => setMode('direct'));
  modeToggleArea.mousePressed(() => setMode('area'));
  modeToggleDiv.child(modeToggleDirect);
  modeToggleDiv.child(modeToggleArea);
  modeGroup.child(modeToggleDiv);
  controlsDiv.child(modeGroup);
  
  // Cell count control (visible in direct mode)
  const cellCountGroup = createDiv();
  cellCountGroup.class('control-group');
  cellCountGroup.id('cell-count-group');
  cellCountGroup.html(`<label>Number of Cells (N):</label>`);
  cellCountSlider = createSlider(5, 100, params.cellCount, 1);
  cellCountSlider.input(() => {
    if (params.mode === 'direct') {
      params.cellCount = cellCountSlider.value();
      cellCountInput.value(params.cellCount);
      generateVoronoi();
    }
  });
  cellCountInput = createInput(params.cellCount, 'number');
  cellCountInput.attribute('min', '5');
  cellCountInput.attribute('max', '100');
  cellCountInput.input(() => {
    if (params.mode === 'direct') {
      let val = parseInt(cellCountInput.value());
      val = constrain(val, 5, 100);
      params.cellCount = val;
      cellCountSlider.value(val);
      generateVoronoi();
    }
  });
  cellCountGroup.child(cellCountSlider);
  cellCountGroup.child(cellCountInput);
  controlsDiv.child(cellCountGroup);
  
  // Area percentage control (visible in area mode)
  const areaPctGroup = createDiv();
  areaPctGroup.class('control-group');
  areaPctGroup.id('area-pct-group');
  areaPctGroup.html(`<label>Target Cell Area (% of circle):</label>`);
  areaPctSlider = createSlider(0.5, 10, params.targetAreaPct, 0.1);
  areaPctSlider.input(() => {
    if (params.mode === 'area') {
      params.targetAreaPct = areaPctSlider.value();
      areaPctInput.value(params.targetAreaPct.toFixed(1));
      updateCellCountFromArea();
      generateVoronoi();
    }
  });
  areaPctInput = createInput(params.targetAreaPct.toFixed(1), 'number');
  areaPctInput.attribute('step', '0.1');
  areaPctInput.attribute('min', '0.5');
  areaPctInput.attribute('max', '10');
  areaPctInput.input(() => {
    if (params.mode === 'area') {
      let val = parseFloat(areaPctInput.value());
      val = constrain(val, 0.5, 10);
      params.targetAreaPct = val;
      areaPctSlider.value(val);
      updateCellCountFromArea();
      generateVoronoi();
    }
  });
  areaPctGroup.child(areaPctSlider);
  areaPctGroup.child(areaPctInput);
  controlsDiv.child(areaPctGroup);
  
  // Circle diameter ratio
  const diameterGroup = createDiv();
  diameterGroup.class('control-group');
  diameterGroup.html(`<label>Circle Diameter Ratio:</label>`);
  diameterSlider = createSlider(0.5, 0.95, params.circleDiameterRatio, 0.01);
  diameterSlider.input(() => {
    params.circleDiameterRatio = diameterSlider.value();
    diameterInput.value(params.circleDiameterRatio.toFixed(2));
    circleRadius = (width * params.circleDiameterRatio) / 2;
    if (params.mode === 'area') {
      updateCellCountFromArea();
    }
    generateVoronoi();
  });
  diameterInput = createInput(params.circleDiameterRatio.toFixed(2), 'number');
  diameterInput.attribute('step', '0.01');
  diameterInput.attribute('min', '0.5');
  diameterInput.attribute('max', '0.95');
  diameterInput.input(() => {
    let val = parseFloat(diameterInput.value());
    val = constrain(val, 0.5, 0.95);
    params.circleDiameterRatio = val;
    diameterSlider.value(val);
    circleRadius = (width * params.circleDiameterRatio) / 2;
    if (params.mode === 'area') {
      updateCellCountFromArea();
    }
    generateVoronoi();
  });
  diameterGroup.child(diameterSlider);
  diameterGroup.child(diameterInput);
  controlsDiv.child(diameterGroup);
  
  // Voronoi line thickness
  const voronoiThicknessGroup = createDiv();
  voronoiThicknessGroup.class('control-group');
  voronoiThicknessGroup.html(`<label>Voronoi Line Thickness:</label>`);
  voronoiThicknessSlider = createSlider(2, 30, params.voronoiStrokeWeight, 1);
  voronoiThicknessSlider.input(() => {
    params.voronoiStrokeWeight = voronoiThicknessSlider.value();
    voronoiThicknessInput.value(params.voronoiStrokeWeight);
  });
  voronoiThicknessInput = createInput(params.voronoiStrokeWeight, 'number');
  voronoiThicknessInput.attribute('min', '2');
  voronoiThicknessInput.attribute('max', '30');
  voronoiThicknessInput.input(() => {
    let val = parseInt(voronoiThicknessInput.value());
    val = constrain(val, 2, 30);
    params.voronoiStrokeWeight = val;
    voronoiThicknessSlider.value(val);
  });
  voronoiThicknessGroup.child(voronoiThicknessSlider);
  voronoiThicknessGroup.child(voronoiThicknessInput);
  controlsDiv.child(voronoiThicknessGroup);
  
  // Circle stroke thickness
  const circleThicknessGroup = createDiv();
  circleThicknessGroup.class('control-group');
  circleThicknessGroup.html(`<label>Circle Outline Thickness:</label>`);
  circleThicknessSlider = createSlider(2, 40, params.circleStrokeWeight, 1);
  circleThicknessSlider.input(() => {
    params.circleStrokeWeight = circleThicknessSlider.value();
    circleThicknessInput.value(params.circleStrokeWeight);
  });
  circleThicknessInput = createInput(params.circleStrokeWeight, 'number');
  circleThicknessInput.attribute('min', '2');
  circleThicknessInput.attribute('max', '40');
  circleThicknessInput.input(() => {
    let val = parseInt(circleThicknessInput.value());
    val = constrain(val, 2, 40);
    params.circleStrokeWeight = val;
    circleThicknessSlider.value(val);
  });
  circleThicknessGroup.child(circleThicknessSlider);
  circleThicknessGroup.child(circleThicknessInput);
  controlsDiv.child(circleThicknessGroup);
  
  // Corner style
  const cornerGroup = createDiv();
  cornerGroup.class('control-group');
  cornerGroup.html(`<label>Corner Style:</label>`);
  cornerStyleSelect = createSelect();
  cornerStyleSelect.option('MITER');
  cornerStyleSelect.option('ROUND');
  cornerStyleSelect.value(params.cornerStyle);
  cornerStyleSelect.changed(() => {
    params.cornerStyle = cornerStyleSelect.value();
  });
  cornerGroup.child(cornerStyleSelect);
  controlsDiv.child(cornerGroup);
  
  // Corner radius
  const cornerRadiusGroup = createDiv();
  cornerRadiusGroup.class('control-group');
  cornerRadiusGroup.html(`<label>Corner Radius:</label>`);
  cornerRadiusSlider = createSlider(0, 50, params.cornerRadius, 1);
  cornerRadiusSlider.input(() => {
    params.cornerRadius = cornerRadiusSlider.value();
    cornerRadiusInput.value(params.cornerRadius);
  });
  cornerRadiusInput = createInput(params.cornerRadius, 'number');
  cornerRadiusInput.attribute('min', '0');
  cornerRadiusInput.attribute('max', '50');
  cornerRadiusInput.input(() => {
    let val = parseInt(cornerRadiusInput.value());
    val = constrain(val, 0, 50);
    params.cornerRadius = val;
    cornerRadiusSlider.value(val);
  });
  cornerRadiusGroup.child(cornerRadiusSlider);
  cornerRadiusGroup.child(cornerRadiusInput);
  controlsDiv.child(cornerRadiusGroup);
  
  // Stroke color
  const strokeColorGroup = createDiv();
  strokeColorGroup.class('control-group');
  strokeColorGroup.html(`<label>Line Color:</label>`);
  strokeColorInput = createColorPicker(params.strokeColor);
  strokeColorInput.input(() => {
    params.strokeColor = strokeColorInput.value();
  });
  strokeColorGroup.child(strokeColorInput);
  controlsDiv.child(strokeColorGroup);
  
  // Fill color
  const fillColorGroup = createDiv();
  fillColorGroup.class('control-group');
  fillColorGroup.html(`<label>Fill Color:</label>`);
  const fillColorValue = params.fillColor === 'none' ? '#000000' : params.fillColor;
  fillColorInput = createColorPicker(fillColorValue);
  const noFillCheckbox = createCheckbox('No Fill', params.fillColor === 'none');
  if (params.fillColor === 'none') {
    fillColorInput.attribute('disabled', true);
  }
  fillColorInput.input(() => {
    if (!noFillCheckbox.checked()) {
      params.fillColor = fillColorInput.value();
    }
  });
  noFillCheckbox.changed(() => {
    if (noFillCheckbox.checked()) {
      params.fillColor = 'none';
      fillColorInput.attribute('disabled', true);
    } else {
      fillColorInput.removeAttribute('disabled');
      params.fillColor = fillColorInput.value();
    }
  });
  fillColorGroup.child(fillColorInput);
  fillColorGroup.child(noFillCheckbox);
  controlsDiv.child(fillColorGroup);
  
  // Download button
  downloadButton = createButton('Download SVG');
  downloadButton.mousePressed(downloadSVG);
  downloadButton.style('margin-top', '20px');
  controlsDiv.child(downloadButton);
  
  updateUIForMode();
}

function setMode(mode) {
  params.mode = mode;
  updateUIForMode();
  if (mode === 'area') {
    updateCellCountFromArea();
  }
  generateVoronoi();
}

function updateUIForMode() {
  if (params.mode === 'direct') {
    select('#cell-count-group').style('display', 'flex');
    select('#area-pct-group').style('display', 'none');
    modeToggleDirect.class('active');
    modeToggleArea.removeClass('active');
  } else {
    select('#cell-count-group').style('display', 'none');
    select('#area-pct-group').style('display', 'flex');
    modeToggleArea.class('active');
    modeToggleDirect.removeClass('active');
  }
}

function updateCellCountFromArea() {
  const circleArea = PI * circleRadius * circleRadius;
  const targetCellArea = (params.targetAreaPct / 100) * circleArea;
  params.cellCount = max(5, round(circleArea / targetCellArea));
  if (cellCountSlider) {
    cellCountSlider.value(params.cellCount);
  }
  if (cellCountInput) {
    cellCountInput.value(params.cellCount);
  }
}

// Generate uniformly distributed points inside circle
function generateSeedPoints() {
  seedPoints = [];
  const maxAttempts = params.cellCount * 10;
  let attempts = 0;
  
  while (seedPoints.length < params.cellCount && attempts < maxAttempts) {
    // Generate point in square
    const x = random(width);
    const y = random(height);
    
    // Check if inside circle
    const dx = x - circleCenterX;
    const dy = y - circleCenterY;
    const distSq = dx * dx + dy * dy;
    
    if (distSq <= circleRadius * circleRadius) {
      seedPoints.push([x, y]);
    }
    attempts++;
  }
  
  // If we didn't get enough points, use area-correct sampling
  while (seedPoints.length < params.cellCount) {
    const angle = random(TWO_PI);
    const r = circleRadius * sqrt(random()); // Area-correct distribution
    const x = circleCenterX + r * cos(angle);
    const y = circleCenterY + r * sin(angle);
    seedPoints.push([x, y]);
  }
}

// Generate Voronoi diagram
function generateVoronoi() {
  generateSeedPoints();
  
  if (seedPoints.length < 3) {
    voronoiCells = [];
    return;
  }
  
  // Create Delaunay triangulation
  delaunay = d3.Delaunay.from(seedPoints);
  
  // Get Voronoi diagram with extended bounds
  const bounds = [-width, -height, width * 2, height * 2];
  const voronoi = delaunay.voronoi(bounds);
  
  // Extract and clip cells
  voronoiCells = [];
  for (let i = 0; i < seedPoints.length; i++) {
    // Get cell polygon vertices directly
    const cellPolygon = getVoronoiCellPolygon(voronoi, i);
    if (cellPolygon && cellPolygon.length >= 3) {
      const clippedCell = clipPolygonToCircleVertices(cellPolygon, circleCenterX, circleCenterY, circleRadius);
      if (clippedCell && clippedCell.length >= 3) {
        voronoiCells.push(clippedCell);
      }
    }
  }
}

// Extract Voronoi cell as polygon vertices
function getVoronoiCellPolygon(voronoi, i) {
  const cell = voronoi.renderCell(i);
  if (!cell || cell === '') return null;
  
  // Parse the path
  const points = parsePathData(cell);
  return points.length >= 3 ? points : null;
}

// Helper: check if point is on circle boundary
function isOnCircle(x, y, cx, cy, r, tolerance = 0.5) {
  const dx = x - cx;
  const dy = y - cy;
  const dist = sqrt(dx * dx + dy * dy);
  return abs(dist - r) < tolerance;
}

// Helper: get angle of point on circle
function getCircleAngle(x, y, cx, cy) {
  return atan2(y - cy, x - cx);
}

// Helper: create arc points along circle between two angles
function createCircleArc(cx, cy, r, angle1, angle2, numPoints = 20) {
  const points = [];
  // Normalize angles and determine sweep direction
  let da = angle2 - angle1;
  while (da > PI) da -= TWO_PI;
  while (da < -PI) da += TWO_PI;
  
  // If angles are very close, return empty
  if (abs(da) < 0.01) return points;
  
  // Adjust number of points based on arc length
  const arcLength = abs(da) * r;
  const actualNumPoints = max(3, min(numPoints, ceil(arcLength / 5)));
  
  for (let i = 1; i < actualNumPoints; i++) {
    const t = i / actualNumPoints;
    const angle = angle1 + da * t;
    points.push([cx + r * cos(angle), cy + r * sin(angle)]);
  }
  
  return points;
}

// Clip polygon vertices to circle boundary with curved edges
function clipPolygonToCircleVertices(vertices, cx, cy, r) {
  if (!vertices || vertices.length < 3) return null;
  
  const tolerance = 0.5; // Increased for boundary detection
  const rSq = r * r;
  
  // Helper: check if point is inside circle
  function isInsideCircle(x, y) {
    const dx = x - cx;
    const dy = y - cy;
    return (dx * dx + dy * dy) <= rSq + tolerance;
  }
  
  // Clip each edge of the polygon
  const clippedPoints = [];
  
  for (let i = 0; i < vertices.length; i++) {
    const p1 = vertices[i];
    const p2 = vertices[(i + 1) % vertices.length];
    
    const inside1 = isInsideCircle(p1[0], p1[1]);
    const inside2 = isInsideCircle(p2[0], p2[1]);
    const onCircle1 = isOnCircle(p1[0], p1[1], cx, cy, r, tolerance);
    const onCircle2 = isOnCircle(p2[0], p2[1], cx, cy, r, tolerance);
    
    if (inside1 && inside2) {
      // Both inside: add p1
      clippedPoints.push([p1[0], p1[1]]);
    } else if (inside1 && !inside2) {
      // Entering: add p1 and intersection
      clippedPoints.push([p1[0], p1[1]]);
      const intersections = lineCircleIntersection(
        p1[0], p1[1], p2[0], p2[1], cx, cy, r
      );
      if (intersections.length > 0) {
        clippedPoints.push(intersections[0]);
      }
    } else if (!inside1 && inside2) {
      // Exiting: add intersection
      const intersections = lineCircleIntersection(
        p1[0], p1[1], p2[0], p2[1], cx, cy, r
      );
      if (intersections.length > 0) {
        clippedPoints.push(intersections[0]);
      }
    } else if (onCircle1 && onCircle2) {
      // Both points on circle: create arc between them
      const angle1 = getCircleAngle(p1[0], p1[1], cx, cy);
      const angle2 = getCircleAngle(p2[0], p2[1], cx, cy);
      const arcPoints = createCircleArc(cx, cy, r, angle1, angle2);
      clippedPoints.push([p1[0], p1[1]]);
      for (const arcPoint of arcPoints) {
        clippedPoints.push(arcPoint);
      }
    }
    // Both outside: add nothing
  }
  
  // If polygon is entirely outside, try to clip edges that cross the boundary
  if (clippedPoints.length === 0) {
    // Check if any edge intersects the circle
    for (let i = 0; i < vertices.length; i++) {
      const p1 = vertices[i];
      const p2 = vertices[(i + 1) % vertices.length];
      const intersections = lineCircleIntersection(
        p1[0], p1[1], p2[0], p2[1], cx, cy, r
      );
      for (const intersection of intersections) {
        clippedPoints.push(intersection);
      }
    }
  }
  
  // Process to add arcs for consecutive boundary points
  const result = [];
  const n = clippedPoints.length;
  
  for (let i = 0; i < n; i++) {
    const p1 = clippedPoints[i];
    const p2 = clippedPoints[(i + 1) % n];
    
    const onCircle1 = isOnCircle(p1[0], p1[1], cx, cy, r, tolerance);
    const onCircle2 = isOnCircle(p2[0], p2[1], cx, cy, r, tolerance);
    
    if (onCircle1 && onCircle2) {
      // Both on circle: add first point, then arc points
      if (result.length === 0 || 
          sqrt((result[result.length - 1][0] - p1[0]) ** 2 + 
               (result[result.length - 1][1] - p1[1]) ** 2) > tolerance) {
        result.push([p1[0], p1[1]]);
      }
      
      const angle1 = getCircleAngle(p1[0], p1[1], cx, cy);
      const angle2 = getCircleAngle(p2[0], p2[1], cx, cy);
      const arcPoints = createCircleArc(cx, cy, r, angle1, angle2);
      
      for (const arcPoint of arcPoints) {
        result.push(arcPoint);
      }
    } else {
      // Regular point
      if (result.length === 0 || 
          sqrt((result[result.length - 1][0] - p1[0]) ** 2 + 
               (result[result.length - 1][1] - p1[1]) ** 2) > tolerance) {
        result.push([p1[0], p1[1]]);
      }
    }
  }
  
  // Remove duplicate consecutive points
  const cleaned = [];
  for (let i = 0; i < result.length; i++) {
    const p = result[i];
    if (cleaned.length === 0) {
      cleaned.push(p);
    } else {
      const prevP = cleaned[cleaned.length - 1];
      const dist = sqrt((p[0] - prevP[0]) ** 2 + (p[1] - prevP[1]) ** 2);
      if (dist > tolerance * 0.5) {
        cleaned.push(p);
      }
    }
  }
  
  // Ensure polygon is closed
  if (cleaned.length >= 2) {
    const first = cleaned[0];
    const last = cleaned[cleaned.length - 1];
    const dist = sqrt((first[0] - last[0]) ** 2 + (first[1] - last[1]) ** 2);
    if (dist > tolerance) {
      // Check if both are on circle and need arc
      const firstOnCircle = isOnCircle(first[0], first[1], cx, cy, r, tolerance);
      const lastOnCircle = isOnCircle(last[0], last[1], cx, cy, r, tolerance);
      
      if (firstOnCircle && lastOnCircle) {
        const angle1 = getCircleAngle(last[0], last[1], cx, cy);
        const angle2 = getCircleAngle(first[0], first[1], cx, cy);
        const arcPoints = createCircleArc(cx, cy, r, angle1, angle2);
        for (const arcPoint of arcPoints) {
          cleaned.push(arcPoint);
        }
      } else {
        cleaned.push([first[0], first[1]]);
      }
    }
  }
  
  return cleaned.length >= 3 ? cleaned : null;
}

// Parse SVG path data into array of [x, y] points
function parsePathData(pathData) {
  if (!pathData || pathData === '') return [];
  
  const points = [];
  // Handle both "M x,y L x,y ..." and "Mx,yLx,y..." formats
  const parts = pathData.trim().split(/[MLZ]/).filter(p => p.trim() !== '');
  
  for (const part of parts) {
    // Split by comma or whitespace
    const coords = part.trim().split(/[,\s]+/).map(parseFloat).filter(n => !isNaN(n));
    if (coords.length >= 2) {
      points.push([coords[0], coords[1]]);
    }
  }
  
  return points;
}

// Find intersections between line segment and circle
function lineCircleIntersection(x1, y1, x2, y2, cx, cy, r) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const fx = x1 - cx;
  const fy = y1 - cy;
  
  const a = dx * dx + dy * dy;
  const b = 2 * (fx * dx + fy * dy);
  const c = fx * fx + fy * fy - r * r;
  
  const discriminant = b * b - 4 * a * c;
  if (discriminant < 0) return [];
  
  const sqrtDisc = sqrt(discriminant);
  const t1 = (-b - sqrtDisc) / (2 * a);
  const t2 = (-b + sqrtDisc) / (2 * a);
  
  const intersections = [];
  if (t1 >= 0 && t1 <= 1) {
    intersections.push([x1 + t1 * dx, y1 + t1 * dy]);
  }
  if (t2 >= 0 && t2 <= 1 && abs(t2 - t1) > 0.001) {
    intersections.push([x1 + t2 * dx, y1 + t2 * dy]);
  }
  
  return intersections;
}

// Round corners of a polygon (outward rounding)
function roundPolygonCorners(points, radius) {
  if (radius <= 0 || points.length < 3) return points;
  
  const rounded = [];
  const n = points.length;
  const epsilon = 0.0001; // Very small threshold
  const minEdgeFraction = 0.01; // Very small minimum edge to preserve
  const maxEdgeFraction = 0.49; // Very large maximum edge to cut
  const minRoundingRadius = 0.5; // Minimum radius to always apply
  
  for (let i = 0; i < n; i++) {
    const p0 = points[(i - 1 + n) % n];
    const p1 = points[i];
    const p2 = points[(i + 1) % n];
    
    // Vectors from p1 to neighbors
    const v1x = p0[0] - p1[0];
    const v1y = p0[1] - p1[1];
    const v2x = p2[0] - p1[0];
    const v2y = p2[1] - p1[1];
    
    const len1 = sqrt(v1x * v1x + v1y * v1y);
    const len2 = sqrt(v2x * v2x + v2y * v2y);
    
    // Always try to round, even for very short edges
    if (len1 < epsilon * 10 || len2 < epsilon * 10) {
      // For extremely short edges, use proportional rounding
      const minLen = min(len1, len2);
      if (minLen > 0) {
        const useRadius = min(radius, minLen * 0.8);
        if (useRadius > 0.1) {
          const u1x = len1 > 0 ? v1x / len1 : 0;
          const u1y = len1 > 0 ? v1y / len1 : 0;
          const u2x = len2 > 0 ? v2x / len2 : 0;
          const u2y = len2 > 0 ? v2y / len2 : 0;
          const cut = minLen * 0.3;
          const cp1x = p1[0] + u1x * cut;
          const cp1y = p1[1] + u1y * cut;
          const cp2x = p1[0] + u2x * cut;
          const cp2y = p1[1] + u2y * cut;
          if (rounded.length === 0 || 
              sqrt((rounded[rounded.length - 1][0] - cp1x) ** 2 + 
                   (rounded[rounded.length - 1][1] - cp1y) ** 2) > epsilon) {
            rounded.push([cp1x, cp1y]);
          }
          // Add rounded corner
          const midX = (cp1x + cp2x) / 2;
          const midY = (cp1y + cp2y) / 2;
          rounded.push([midX, midY]);
          continue;
        }
      }
      if (rounded.length === 0 || 
          sqrt((rounded[rounded.length - 1][0] - p1[0]) ** 2 + 
               (rounded[rounded.length - 1][1] - p1[1]) ** 2) > epsilon) {
        rounded.push(p1);
      }
      continue;
    }
    
    // Normalize
    const u1x = v1x / len1;
    const u1y = v1y / len1;
    const u2x = v2x / len2;
    const u2y = v2y / len2;
    
    // Angle between vectors
    const dot = u1x * u2x + u1y * u2y;
    const angle = acos(constrain(dot, -1, 1));
    
    // Always round, even for extreme angles
    let useRadius = radius;
    let actualCut;
    let needsFallback = false;
    
    if (angle < 0.01 || angle > PI - 0.01) {
      // For very sharp or very wide angles, use proportional rounding
      needsFallback = true;
      const minEdge = min(len1, len2);
      useRadius = min(radius, minEdge * 0.4);
      actualCut = minEdge * 0.2;
    } else {
      const halfAngle = angle / 2;
      
      // Calculate maximum safe radius for this corner - very generous
      const minEdge = min(len1, len2);
      const maxSafeRadius = minEdge * maxEdgeFraction * sin(halfAngle) * 2.0;
      useRadius = min(radius, maxSafeRadius);
      
      // Distance to cut along edges
      const cutDist = useRadius / max(tan(halfAngle), 0.01);
      
      // Limit cut distance
      const maxCut1 = len1 * maxEdgeFraction;
      const maxCut2 = len2 * maxEdgeFraction;
      actualCut = min(cutDist, maxCut1, maxCut2);
      
      // If cut is too small, use fallback
      if (actualCut < epsilon * 50) {
        needsFallback = true;
        const minEdge = min(len1, len2);
        useRadius = min(radius, minEdge * 0.3);
        actualCut = minEdge * 0.15;
      }
    }
    
    // Always apply rounding - use fallback if needed
    if (useRadius <= 0.1 || actualCut <= epsilon) {
      // Final fallback: always round with minimal amount
      const minEdge = min(len1, len2);
      useRadius = min(radius, minEdge * 0.2, minRoundingRadius);
      actualCut = minEdge * 0.1;
    }
    
    // Calculate cut points
    const cp1x = p1[0] + u1x * actualCut;
    const cp1y = p1[1] + u1y * actualCut;
    const cp2x = p1[0] + u2x * actualCut;
    const cp2y = p1[1] + u2y * actualCut;
    
    // Add start point
    if (rounded.length === 0 || 
        sqrt((rounded[rounded.length - 1][0] - cp1x) ** 2 + 
             (rounded[rounded.length - 1][1] - cp1y) ** 2) > epsilon) {
      rounded.push([cp1x, cp1y]);
    }
    
    // Calculate arc if we have enough radius
    if (useRadius > 0.5 && !needsFallback && angle > 0.01 && angle < PI - 0.01) {
      const halfAngle = angle / 2;
      
      // Bisector direction
      const bisectorX = u1x + u2x;
      const bisectorY = u1y + u2y;
      const bisectorLen = sqrt(bisectorX * bisectorX + bisectorY * bisectorY);
      
      if (bisectorLen > epsilon) {
        const bisectorNormX = bisectorX / bisectorLen;
        const bisectorNormY = bisectorY / bisectorLen;
        
        // Arc center
        const centerDist = useRadius / sin(halfAngle);
        const centerX = p1[0] + bisectorNormX * centerDist;
        const centerY = p1[1] + bisectorNormY * centerDist;
        
        // Arc angles
        const a1 = atan2(cp1y - centerY, cp1x - centerX);
        const a2 = atan2(cp2y - centerY, cp2x - centerX);
        
        let da = a2 - a1;
        while (da > PI) da -= TWO_PI;
        while (da < -PI) da += TWO_PI;
        
        if (abs(da) > 0.1) {
          const numSegments = max(4, min(20, ceil(abs(da) * useRadius / 2)));
          for (let j = 1; j < numSegments; j++) {
            const t = j / numSegments;
            const a = a1 + da * t;
            const arcX = centerX + useRadius * cos(a);
            const arcY = centerY + useRadius * sin(a);
            if (isFinite(arcX) && isFinite(arcY)) {
              rounded.push([arcX, arcY]);
            }
          }
        }
      }
    } else {
      // Simple rounded corner for fallback cases
      const midX = (cp1x + cp2x) / 2;
      const midY = (cp1y + cp2y) / 2;
      rounded.push([midX, midY]);
    }
  }
  
  return rounded.length >= 3 ? rounded : points;
}

function draw() {
  background(0);
  
  // Convert hex color to RGB
  function hexToRgb(hex) {
    if (hex === 'none') return null;
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
  
  // Set stroke style
  const strokeRgb = hexToRgb(params.strokeColor);
  if (strokeRgb) {
    stroke(strokeRgb.r, strokeRgb.g, strokeRgb.b);
  } else {
    noStroke();
  }
  
  // Set fill style
  if (params.fillColor === 'none') {
    noFill();
  } else {
    const fillRgb = hexToRgb(params.fillColor);
    if (fillRgb) {
      fill(fillRgb.r, fillRgb.g, fillRgb.b);
    } else {
      noFill();
    }
  }
  
  if (params.cornerStyle === 'MITER') {
    strokeJoin(MITER);
  } else {
    strokeJoin(ROUND);
  }
  
  // Draw Voronoi cells
  strokeWeight(params.voronoiStrokeWeight);
  for (const cell of voronoiCells) {
    if (cell && cell.length >= 3) {
      if (params.cornerRadius > 0) {
        // Use rounded corners
        const pointsToDraw = roundPolygonCorners(cell, params.cornerRadius);
        beginShape();
        for (const point of pointsToDraw) {
          vertex(point[0], point[1]);
        }
        endShape(CLOSE);
      } else {
        // Sharp corners
        beginShape();
        for (const point of cell) {
          vertex(point[0], point[1]);
        }
        endShape(CLOSE);
      }
    }
  }
}

// Export as SVG
function downloadSVG() {
  const svg = generateSVG();
  const blob = new Blob([svg], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'voronoi-circle.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function generateSVG() {
  const strokeJoinStyle = params.cornerStyle === 'MITER' ? 'miter' : 'round';
  const strokeColor = params.strokeColor === 'none' ? 'none' : params.strokeColor;
  const fillColor = params.fillColor === 'none' ? 'none' : params.fillColor;
  
  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${params.canvasSize}" 
     height="${params.canvasSize}" 
     viewBox="0 0 ${params.canvasSize} ${params.canvasSize}">
  <defs>
    <clipPath id="circleClip">
      <circle cx="${circleCenterX}" cy="${circleCenterY}" r="${circleRadius}"/>
    </clipPath>
  </defs>
  <rect width="100%" height="100%" fill="black"/>
  <g clip-path="url(#circleClip)">
`;
  
  // Add Voronoi cell paths
  for (const cell of voronoiCells) {
    if (cell && cell.length >= 3) {
      // Apply rounded corners if radius > 0
      const pointsToDraw = params.cornerRadius > 0 
        ? roundPolygonCorners(cell, params.cornerRadius)
        : cell;
      
      let pathData = `M ${pointsToDraw[0][0]} ${pointsToDraw[0][1]}`;
      for (let i = 1; i < pointsToDraw.length; i++) {
        pathData += ` L ${pointsToDraw[i][0]} ${pointsToDraw[i][1]}`;
      }
      pathData += ' Z'; // Close path
      
      const strokeAttr = strokeColor === 'none' ? 'stroke="none"' : `stroke="${strokeColor}"`;
      const fillAttr = fillColor === 'none' ? 'fill="none"' : `fill="${fillColor}"`;
      
      svg += `    <path d="${pathData}" 
           ${fillAttr}
           ${strokeAttr}
           stroke-width="${params.voronoiStrokeWeight}" 
           stroke-linejoin="${strokeJoinStyle}"/>\n`;
    }
  }
  
  svg += `  </g>
</svg>`;
  
  return svg;
}
    </script>
</body>
</html>
